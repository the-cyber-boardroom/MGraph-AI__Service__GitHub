# MGraph-AI Service GitHub - Testing Briefing

## Document Information

| Field | Value |
|-------|-------|
| Service | MGraph-AI Service GitHub |
| Version | v0.8.0 |
| Package | https://pypi.org/project/mgraph-ai-service-github |
| Purpose | Testing guide for dependent services |
| Focus | Local testing without network dependencies |

---

## Executive Summary

This document describes how to **test services that depend on the GitHub Service** (e.g., Deploy Service) without requiring network access, GitHub credentials, or the live `github.dev.mgraph.ai` deployment.

The approach uses a **three-layer testing architecture**:
1. **Your Service** (being tested) uses the GitHub Service Client
2. **GitHub Service** runs locally as an in-memory FastAPI instance
3. **GitHub API Surrogate** intercepts all GitHub API calls

The result: **fully isolated, fast, deterministic tests** that exercise your real production code paths.

---

## The Testing Challenge

### Problem

When testing a service like Deploy Service that depends on GitHub Service:

```
┌─────────────────────────────────────────────────────────────────────┐
│                    Deploy Service (being tested)                     │
└─────────────────────────────────────────────────────────────────────┘
                                │
                                │ HTTPS
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│              github.dev.mgraph.ai (production)                       │
└─────────────────────────────────────────────────────────────────────┘
                                │
                                │ HTTPS
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│                    api.github.com (real GitHub)                      │
└─────────────────────────────────────────────────────────────────────┘
```

This creates multiple problems:
- **Network dependency** - Tests fail offline or with connectivity issues
- **Credentials required** - Need valid GitHub PAT in test environment
- **Rate limits** - GitHub API limits (5,000/hour) can block CI pipelines
- **Slow** - Each HTTP hop adds 100-500ms latency
- **Side effects** - Tests may create/modify real GitHub secrets
- **Non-deterministic** - External service state can vary

### Solution

Run the entire stack locally and in-memory:

```
┌─────────────────────────────────────────────────────────────────────┐
│                    Deploy Service (being tested)                     │
└─────────────────────────────────────────────────────────────────────┘
                                │
                                │ In-memory (TestClient)
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│              GitHub Service (local FastAPI instance)                 │
│                  from mgraph-ai-service-github                       │
└─────────────────────────────────────────────────────────────────────┘
                                │
                                │ In-memory (session factory)
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│                    GitHub API Surrogate                              │
│                  (mocks api.github.com)                              │
└─────────────────────────────────────────────────────────────────────┘
```

**Result**: The entire integration runs in ~10ms instead of ~2 seconds, with zero network calls.

---

## Architecture Overview

### Component Stack

```
┌─────────────────────────────────────────────────────────────────────┐
│                        Your Test Code                                │
│                                                                      │
│   def test_deploy_creates_secrets(self):                            │
│       result = self.deploy_service.deploy(config)                   │
│       assert result.success is True                                  │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
                                │
                                │ uses
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│                    Deploy Service                                    │
│                 (your production code)                               │
│                                                                      │
│   def deploy(self, config):                                         │
│       self.github_client.create_repo_secret(...)                    │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
                                │
                                │ HTTP calls to
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│                GitHub__Service__Client                               │
│            (pointed at local FastAPI app)                            │
│                                                                      │
│   base_url = local TestClient (not https://github.dev.mgraph.ai)    │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
                                │
                                │ in-memory HTTP
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│              GitHub Service FastAPI App                              │
│           (from mgraph-ai-service-github package)                    │
│                                                                      │
│   Routes:                                                            │
│   - /encryption/public-key                                           │
│   - /github-secrets-repo/list, create, get, update, delete          │
│   - /github-secrets-env/list, create, get, update, delete           │
│   - /github-secrets-org/list, create, get, update, delete           │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
                                │
                                │ uses GitHub__API with surrogate session
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│                  GitHub__API__Surrogate                              │
│              (in-memory mock of api.github.com)                      │
│                                                                      │
│   State:                                                             │
│   - Repositories, Environments, Organizations                        │
│   - Secrets (repo/env/org scopes)                                   │
│   - Public keys for encryption                                       │
│   - Configurable PATs with different permissions                     │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### Key Components

| Component | Source | Purpose |
|-----------|--------|---------|
| `GitHub__Service__Fast_API` | `mgraph-ai-service-github` package | Local instance of the GitHub Service |
| `GitHub__API__Surrogate` | `mgraph-ai-service-github` package | Mock GitHub API with in-memory state |
| `GitHub__API__Surrogate__Test_Context` | `mgraph-ai-service-github` package | Test helper for setup/teardown |
| `Client__GitHub__Service` | Your service | Client that talks to GitHub Service |

---

## Implementation Guide

### Step 1: Install the Package

```bash
pip install mgraph-ai-service-github
```

Or in `pyproject.toml`:
```toml
[tool.poetry.dependencies]
mgraph-ai-service-github = "^0.8.0"
```

### Step 2: Create Test Fixtures

Create a helper module for your tests:

```python
# tests/fixtures/github_service_fixtures.py

from typing                                                                     import Tuple
from fastapi                                                                    import FastAPI
from osbot_utils.type_safe.decorators.type_safe                                 import type_safe
from mgraph_ai_service_github.fast_api.GitHub_Service__Fast_API                 import GitHub_Service__Fast_API
from mgraph_ai_service_github.surrogates.github.GitHub__API__Surrogate__Test_Context import GitHub__API__Surrogate__Test_Context
from osbot_fast_api.api.Serverless__Fast_API__Config                            import Serverless__Fast_API__Config


@type_safe
def github_service__fast_api_app() -> Tuple[FastAPI, GitHub__API__Surrogate__Test_Context]:
    """Create a local GitHub Service with surrogate GitHub API."""
    
    # Setup surrogate FIRST - this wires GitHub__API to use in-memory mock
    surrogate_context = GitHub__API__Surrogate__Test_Context().setup()
    
    # Create local GitHub Service instance
    serverless_config       = Serverless__Fast_API__Config(enable_api_key=False)
    github_service_fast_api = GitHub_Service__Fast_API(config=serverless_config).setup()
    fast_api_app            = github_service_fast_api.app()
    
    return fast_api_app, surrogate_context


@type_safe
def client_github_service() -> Tuple['Client__GitHub__Service', GitHub__API__Surrogate__Test_Context]:
    """Create a GitHub Service client connected to local instance."""
    from your_service.clients import Client__GitHub__Service
    
    fast_api_app, surrogate_context = github_service__fast_api_app()
    
    client = Client__GitHub__Service()
    client.set__fast_api_app(fast_api_app)  # Point to local app instead of production URL
    
    return client.client(), surrogate_context
```

### Step 3: Write Tests

```python
# tests/unit/test_deploy_service.py

from unittest import TestCase
from tests.fixtures.github_service_fixtures import client_github_service


class test_Deploy_Service(TestCase):

    @classmethod
    def setUpClass(cls):
        # Get client and surrogate context
        cls.github_client, cls.surrogate_context = client_github_service()
        
        # Configure test data in surrogate
        cls.repo_owner = 'test-org'
        cls.repo_name  = 'test-repo'
        
        cls.surrogate_context.add_repo(cls.repo_owner, cls.repo_name)
        cls.surrogate_context.add_environment(cls.repo_owner, cls.repo_name, 'production')
        cls.surrogate_context.add_environment(cls.repo_owner, cls.repo_name, 'staging')
        
        # Setup your service with the test client
        cls.deploy_service = DeployService(github_client=cls.github_client)

    @classmethod
    def tearDownClass(cls):
        cls.surrogate_context.teardown()

    def test_deploy_creates_repo_secrets(self):
        config = DeployConfig(
            repo_owner  = self.repo_owner,
            repo_name   = self.repo_name,
            secrets     = {'API_KEY': 'secret-value', 'DB_URL': 'postgres://...'}
        )
        
        result = self.deploy_service.deploy(config)
        
        assert result.success is True
        
        # Verify secrets were created via surrogate state
        state = self.surrogate_context.surrogate.state
        assert state.get_repo_secret(self.repo_owner, self.repo_name, 'API_KEY') is not None
        assert state.get_repo_secret(self.repo_owner, self.repo_name, 'DB_URL') is not None

    def test_deploy_creates_environment_secrets(self):
        config = DeployConfig(
            repo_owner  = self.repo_owner,
            repo_name   = self.repo_name,
            environment = 'production',
            secrets     = {'PROD_KEY': 'prod-secret'}
        )
        
        result = self.deploy_service.deploy(config)
        
        assert result.success is True
        
        # Verify environment secret was created
        state = self.surrogate_context.surrogate.state
        secret = state.get_env_secret(self.repo_owner, self.repo_name, 'production', 'PROD_KEY')
        assert secret is not None

    def test_deploy_handles_missing_repo(self):
        config = DeployConfig(
            repo_owner = 'nonexistent-org',
            repo_name  = 'nonexistent-repo',
            secrets    = {'KEY': 'value'}
        )
        
        result = self.deploy_service.deploy(config)
        
        assert result.success is False
        assert 'not found' in result.error.lower()
```

---

## Surrogate Configuration

### Adding Test Data

```python
# Repositories
surrogate_context.add_repo('owner', 'repo')
surrogate_context.add_repo('owner', 'private-repo', private=True)

# Environments
surrogate_context.add_environment('owner', 'repo', 'production')
surrogate_context.add_environment('owner', 'repo', 'staging')
surrogate_context.add_environment('owner', 'repo', 'development')

# Pre-existing Repository Secrets
surrogate_context.add_secret('owner', 'repo', 'EXISTING_SECRET')
surrogate_context.add_secret('owner', 'repo', 'ANOTHER_SECRET', encrypted_value='...')

# Pre-existing Environment Secrets
surrogate_context.add_env_secret('owner', 'repo', 'production', 'PROD_DB_URL')

# Organizations
surrogate_context.add_org('my-org')
surrogate_context.add_org_secret('my-org', 'ORG_WIDE_KEY', visibility='all')
```

### Available Test PATs

The surrogate provides PATs with different permission levels:

```python
surrogate_context.admin_pat()        # Full access to all operations
surrogate_context.repo_write_pat()   # Can read/write repo secrets
surrogate_context.repo_read_pat()    # Can only read repo secrets (write fails)
surrogate_context.org_admin_pat()    # Can manage organization secrets
surrogate_context.expired_pat()      # Always returns 401 Unauthorized
surrogate_context.rate_limited_pat() # Always returns 429 Rate Limited
surrogate_context.invalid_pat()      # Always returns 401 Bad Credentials
surrogate_context.no_scopes_pat()    # Always returns 403 Forbidden
```

Use these to test error handling:

```python
def test_deploy_handles_expired_token(self):
    # Configure client with expired PAT
    self.github_client.set_github_pat(self.surrogate_context.expired_pat())
    
    result = self.deploy_service.deploy(config)
    
    assert result.success is False
    assert result.error_type == 'authentication_failed'

def test_deploy_handles_rate_limit(self):
    self.github_client.set_github_pat(self.surrogate_context.rate_limited_pat())
    
    result = self.deploy_service.deploy(config)
    
    assert result.success is False
    assert result.error_type == 'rate_limited'
```

### Inspecting Surrogate State

After operations, verify state directly:

```python
state = self.surrogate_context.surrogate.state

# Check repositories
assert state.repo_exists('owner', 'repo')

# Check secrets
secret = state.get_repo_secret('owner', 'repo', 'SECRET_NAME')
assert secret is not None
assert secret.name == 'SECRET_NAME'

# List all secrets
secrets = state.list_repo_secrets('owner', 'repo')
assert len(secrets) == 3

# Check environment secrets
env_secret = state.get_env_secret('owner', 'repo', 'production', 'PROD_KEY')

# Check org secrets
org_secret = state.get_org_secret('my-org', 'ORG_KEY')
assert org_secret.visibility == 'all'

# Delete for cleanup
state.delete_repo_secret('owner', 'repo', 'TEMP_SECRET')
```

---

## Complete Example: Cache Service Pattern

Following the Cache Service pattern from your codebase:

```python
# tests/fixtures/service_fixtures.py

from typing                                                                     import Tuple
from fastapi                                                                    import FastAPI
from osbot_utils.type_safe.decorators.type_safe                                 import type_safe

from mgraph_ai_service_github.fast_api.GitHub_Service__Fast_API                 import GitHub_Service__Fast_API
from mgraph_ai_service_github.surrogates.github.GitHub__API__Surrogate__Test_Context import GitHub__API__Surrogate__Test_Context
from osbot_fast_api.api.Serverless__Fast_API__Config                            import Serverless__Fast_API__Config


@type_safe
def github__service__fast_api_app() -> Tuple[FastAPI, GitHub__API__Surrogate__Test_Context]:
    """Create local GitHub Service FastAPI app with surrogate backend."""
    surrogate_context       = GitHub__API__Surrogate__Test_Context().setup()
    serverless_config       = Serverless__Fast_API__Config(enable_api_key=False)
    github_service_fast_api = GitHub_Service__Fast_API(config=serverless_config).setup()
    fast_api_app            = github_service_fast_api.app()
    return fast_api_app, surrogate_context


@type_safe  
def client_github_service() -> Tuple['GitHub__Service__Client', GitHub__API__Surrogate__Test_Context]:
    """Create GitHub Service client connected to local instance."""
    from your_service.clients.github_service_client import GitHub__Service__Client
    
    fast_api_app, surrogate_context = github__service__fast_api_app()
    client_github_service           = GitHub__Service__Client().set__fast_api_app(fast_api_app).client()
    return client_github_service, surrogate_context


# Usage in tests:

class test_My_Feature(TestCase):

    @classmethod
    def setUpClass(cls):
        cls.github_client, cls.surrogate_context = client_github_service()
        
        # Configure surrogate with test data
        cls.surrogate_context.add_repo('test-owner', 'test-repo')
        cls.surrogate_context.add_environment('test-owner', 'test-repo', 'production')
    
    @classmethod
    def tearDownClass(cls):
        cls.surrogate_context.teardown()
    
    def test_feature_works(self):
        # Your test using cls.github_client
        result = self.github_client.list_repo_secrets('test-owner', 'test-repo')
        assert result['response_context']['success'] is True
```

---

## Performance Comparison

| Scenario | With Real Services | With Local + Surrogate |
|----------|-------------------|------------------------|
| Single API call | 200-500ms | 1-5ms |
| Create secret flow | 800-1500ms | 5-15ms |
| Full deployment test | 3-5 seconds | 20-50ms |
| 50 integration tests | 2-4 minutes | 1-2 seconds |

### Why It's Fast

1. **No network I/O** - Everything runs in-process
2. **No TLS handshakes** - No HTTPS overhead
3. **No serialization** - TestClient uses direct Python calls
4. **No rate limiting** - Surrogate doesn't throttle
5. **No authentication delays** - PAT validation is instant

---

## CI/CD Integration

### GitHub Actions Example

```yaml
# .github/workflows/test.yml

name: Tests
on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
      
      - name: Install dependencies
        run: |
          pip install poetry
          poetry install
      
      - name: Run tests
        run: poetry run pytest tests/ -v
        # No GitHub PAT needed!
        # No GITHUB_TOKEN secret required!
        # Tests run fully isolated!
```

### Key Benefits for CI

- **No secrets management** - No PAT tokens in CI environment
- **No rate limit failures** - Unlimited test runs
- **Parallel safe** - Each test job gets isolated state
- **Faster pipelines** - Tests complete in seconds, not minutes
- **More reliable** - No flaky failures from network issues

---

## Troubleshooting

### Common Issues

**Issue: `ImportError: cannot import from mgraph_ai_service_github`**

Solution: Ensure package is installed:
```bash
pip install mgraph-ai-service-github>=0.8.0
```

**Issue: Surrogate returns 404 for repository**

Solution: Add the repository to surrogate state before testing:
```python
surrogate_context.add_repo('owner', 'repo')
```

**Issue: Environment secrets operations fail**

Solution: Add the environment first:
```python
surrogate_context.add_repo('owner', 'repo')
surrogate_context.add_environment('owner', 'repo', 'production')
```

**Issue: Tests interfering with each other**

Solution: Each test class should have its own surrogate context:
```python
@classmethod
def setUpClass(cls):
    cls.surrogate_context = GitHub__API__Surrogate__Test_Context().setup()

@classmethod
def tearDownClass(cls):
    cls.surrogate_context.teardown()
```

---

## Summary

| Step | Action |
|------|--------|
| 1 | Install `mgraph-ai-service-github` package |
| 2 | Create fixture that instantiates local GitHub Service + Surrogate |
| 3 | Point your client at the local FastAPI app |
| 4 | Configure surrogate with test repos, environments, secrets |
| 5 | Write tests using real client code |
| 6 | Verify state via `surrogate_context.surrogate.state` |
| 7 | Call `surrogate_context.teardown()` in tearDownClass |

The result: **fast, reliable, isolated tests** that exercise your real production code paths without any network dependencies or external service requirements.