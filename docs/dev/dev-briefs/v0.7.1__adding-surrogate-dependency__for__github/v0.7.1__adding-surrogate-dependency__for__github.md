# GitHub API Surrogate Architecture Debrief

## Document Purpose

This document provides a comprehensive technical specification for implementing a **Surrogate** for the GitHub REST API within the `mgraph_ai_service_github` package. It is intended to serve as an authoritative reference for implementation, enabling consistent development whether by human developers or LLM assistants.

---

## 1. Problem Statement

### 1.1 The Testing Challenge

The `MGraph-AI__Service__GitHub` project provides a FastAPI-based microservice that wraps GitHub's REST API for managing secrets (repository, environment, and organization-level). This service is consumed by other projects, notably the **Deploy Service**.

When testing the Deploy Service, we face a dependency problem:

```
Deploy Service Tests
    → Deploy Service Code
        → GitHub Service Client (HTTP calls)
            → GitHub Service (FastAPI)
                → GitHub__API class
                    → GitHub REST API (api.github.com)
```

Testing against the real GitHub API is problematic:
- **Rate limiting** constrains test frequency
- **State pollution** from creating/deleting real secrets
- **Credential management** complexity in CI/CD
- **Network dependency** causes flaky tests
- **Cost** for private repositories and organizations

### 1.2 The Wrong Approach (What We're NOT Doing)

An initial attempt created a `GitHub__Service__Stub` that mocked the **GitHub Service** endpoints (`/github-secrets-repo/list`, `/encryption/public-key`, etc.). This is architecturally incorrect because:

1. It bypasses all service code, testing nothing meaningful
2. Deploy Service tests should exercise the real GitHub Service code
3. The untestable external dependency is **GitHub's API**, not our service

### 1.3 The Correct Approach (Surrogate Pattern)

We apply the **Surrogate Pattern** (similar to LocalStack for AWS):

```
Deploy Service Tests
    → Deploy Service Code
        → GitHub Service (real code, in-memory via TestClient)
            → GitHub__API class
                → GitHub__API__Surrogate (mocks api.github.com)
```

The Surrogate:
- Implements GitHub's REST API contract
- Runs in-memory via Starlette TestClient
- Maintains state (users, repos, secrets) in memory
- Validates PATs and enforces permission scopes
- Returns responses matching GitHub's JSON structure

---

## 2. Architecture Overview

### 2.1 Package Location

```
mgraph_ai_service_github/surrogates/github/
├── __init__.py
├── GitHub__API__Surrogate.py              # Main orchestrator and FastAPI app
├── GitHub__API__Surrogate__State.py       # In-memory state management
├── GitHub__API__Surrogate__PATs.py        # PAT definitions and validation
├── GitHub__API__Surrogate__Session.py     # requests.Session-compatible wrapper
├── GitHub__API__Surrogate__Keys.py        # NaCl key pair management
├── GitHub__API__Surrogate__Routes.py      # FastAPI route definitions
└── schemas/
    ├── __init__.py
    ├── Schema__Surrogate__User.py         # GitHub user representation
    ├── Schema__Surrogate__Repo.py         # Repository representation
    ├── Schema__Surrogate__Secret.py       # Secret metadata
    ├── Schema__Surrogate__PAT.py          # PAT with scopes
    ├── Schema__Surrogate__Rate_Limit.py   # Rate limit tracking
    └── Enum__GitHub__Scope.py             # Permission scope enumeration
```

### 2.2 Component Relationships

```
┌─────────────────────────────────────────────────────────────────────┐
│                    GitHub__API__Surrogate                           │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────────────┐  │
│  │    PATs      │  │    State     │  │         Keys             │  │
│  │              │  │              │  │                          │  │
│  │ - admin_pat  │  │ - users      │  │ - generate_key_pair()    │  │
│  │ - readonly   │  │ - repos      │  │ - get_public_key()       │  │
│  │ - expired    │  │ - secrets    │  │ - encrypt()              │  │
│  │ - validate() │  │ - rate_limits│  │                          │  │
│  └──────────────┘  └──────────────┘  └──────────────────────────┘  │
│                              │                                      │
│                              ▼                                      │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │                    FastAPI Application                        │  │
│  │                                                               │  │
│  │  Routes:                                                      │  │
│  │  - GET  /user                                                 │  │
│  │  - GET  /rate_limit                                           │  │
│  │  - GET  /repos/{owner}/{repo}/actions/secrets/public-key      │  │
│  │  - GET  /repos/{owner}/{repo}/actions/secrets                 │  │
│  │  - GET  /repos/{owner}/{repo}/actions/secrets/{name}          │  │
│  │  - PUT  /repos/{owner}/{repo}/actions/secrets/{name}          │  │
│  │  - DELETE /repos/{owner}/{repo}/actions/secrets/{name}        │  │
│  │  - (similar for environments and orgs)                        │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                              │                                      │
│                              ▼                                      │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │              GitHub__API__Surrogate__Session                  │  │
│  │                                                               │  │
│  │  Wraps TestClient to implement requests.Session interface     │  │
│  │  - get(url, **kwargs) -> Response                             │  │
│  │  - put(url, json=None, **kwargs) -> Response                  │  │
│  │  - delete(url, **kwargs) -> Response                          │  │
│  │  - headers.update(dict)                                       │  │
│  └──────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────────┐
│                        GitHub__API                                  │
│                                                                     │
│  Existing class - unchanged except session injection                │
│  - api_token: str                                                   │
│  - api_url: str = 'https://api.github.com'                          │
│  - session() -> Session  ← INJECTION POINT                          │
│  - get(endpoint) -> Dict                                            │
│  - put(endpoint, data) -> Optional[Dict]                            │
│  - delete(endpoint) -> bool                                         │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 3. Key Design Decisions

### 3.1 Decision: Surrogate Location in Package

**Choice:** `mgraph_ai_service_github/surrogates/github/`

**Rationale:**
- The surrogate is **not just for testing** - it's a reusable component for any consumer
- Placing it in `utils/testing/` would suggest it's internal tooling
- The `surrogates/` namespace allows future surrogates (e.g., for other APIs)
- Publishing to PyPI as `mgraph-ai-service-github` makes it available to all consumers
- Deploy Service (and others) simply `pip install mgraph-ai-service-github` and import the surrogate

### 3.2 Decision: Session Injection (Option C)

**Choice:** Replace `GitHub__API.session()` with a TestClient-based wrapper

**Rationale:**
- `GitHub__API` already uses `@cache_on_self` for session management
- Minimal code changes to existing classes
- No need to run a real HTTP server (localhost binding issues in CI)
- TestClient provides synchronous interface matching `requests.Session`
- Clean separation - `GitHub__API` doesn't know it's talking to a surrogate

**Implementation Pattern:**
```python
# The surrogate creates a Session-compatible object
surrogate_session = GitHub__API__Surrogate__Session(test_client=surrogate.test_client())

# Injection replaces the cached session
github_api._cache_on_self__session = surrogate_session
```

### 3.3 Decision: Pre-defined PATs with Role-based Permissions

**Choice:** Static PAT strings with associated permission profiles

**Rationale:**
- Mirrors GitHub's actual token-based authentication
- Enables testing permission boundaries (403 responses)
- Enables testing authentication failures (401 responses)
- Enables testing rate limiting (429 responses)
- PATs are discoverable via methods: `surrogate.pats.admin_pat()`
- Test code is self-documenting: `admin_pat` vs `readonly_pat`

**PAT Categories:**
| PAT Type | Purpose | Behavior |
|----------|---------|----------|
| `PAT__ADMIN` | Full access to all operations | 200/201/204 responses |
| `PAT__REPO_WRITE` | Repo secrets CRUD | 200 for repo, 403 for org |
| `PAT__REPO_READ` | Repo secrets read-only | 200 for GET, 403 for PUT/DELETE |
| `PAT__ORG_ADMIN` | Organization-level access | 200 for org operations |
| `PAT__ENV_ONLY` | Environment secrets only | 200 for env, 403 for repo/org |
| `PAT__EXPIRED` | Simulate expired token | Always 401 |
| `PAT__RATE_LIMITED` | Simulate rate limit hit | Always 429 |
| `PAT__NO_SCOPES` | Valid auth, no permissions | 200 for /user, 403 for all else |

### 3.4 Decision: Model GitHub's Actual Scopes

**Choice:** Implement GitHub's real scope model (`repo`, `admin:org`, `workflow`, etc.)

**Rationale:**
- Accurate permission testing
- Documentation value - developers learn GitHub's permission model
- Future-proof if more granular testing needed
- Scopes are well-documented in GitHub's API docs

**Relevant Scopes:**
```python
class Enum__GitHub__Scope(Enum):
    REPO                = 'repo'           # Full control of private repos
    PUBLIC_REPO         = 'public_repo'    # Access public repos only
    ADMIN_ORG           = 'admin:org'      # Full org admin access
    WRITE_ORG           = 'write:org'      # Read/write org membership
    READ_ORG            = 'read:org'       # Read org membership
    WORKFLOW            = 'workflow'       # Update GitHub Actions workflows
```

### 3.5 Decision: In-Memory State Management

**Choice:** All state in `Type_Safe` classes, reset between tests

**Rationale:**
- No filesystem or database dependencies
- Fast test execution
- Explicit state - tests declare what exists
- `reset()` method ensures test isolation
- State is inspectable for assertions

**State Structure:**
```python
class GitHub__API__Surrogate__State(Type_Safe):
    users          : Dict[str, Schema__Surrogate__User]
    repos          : Dict[str, Schema__Surrogate__Repo]              # key: "owner/repo"
    secrets__repo  : Dict[str, Dict[str, Schema__Surrogate__Secret]] # key: "owner/repo" -> {name -> secret}
    secrets__env   : Dict[str, Dict[str, Dict[str, Schema__Surrogate__Secret]]] # key: "owner/repo" -> {env -> {name -> secret}}
    secrets__org   : Dict[str, Dict[str, Schema__Surrogate__Secret]] # key: "org" -> {name -> secret}
    public_keys    : Dict[str, Schema__Surrogate__Public_Key]        # key: scope identifier
    rate_limits    : Dict[str, Schema__Surrogate__Rate_Limit]        # key: PAT
```

### 3.6 Decision: Real NaCl Key Generation

**Choice:** Generate actual NaCl key pairs per scope

**Rationale:**
- GitHub's secrets API uses libsodium (NaCl) sealed box encryption
- Our service code performs real encryption/decryption
- Using real keys validates the entire encryption flow
- Keys are generated per scope (repo, environment, org) matching GitHub behavior
- The `GitHub__API__Surrogate__Keys` class manages key lifecycle

### 3.7 Decision: Response Fidelity - Fields We Use Only

**Choice:** Return only the JSON fields that our code actually consumes

**Rationale:**
- Full GitHub response fidelity would be extremely complex
- Many fields are unused (avatars, URLs, timestamps, etc.)
- Reduces maintenance burden as GitHub adds fields
- Tests validate our code, not GitHub's schema
- Can expand fields as needed when code requires them

**Example - User Response:**
```python
# GitHub returns ~30+ fields, we return only what GitHub__API uses:
{
    "login": "surrogate-admin",
    "id": 1000001,
    "name": "Surrogate Admin User",
    "email": "admin@surrogate.local",
    "company": "Surrogate Corp",
    "created_at": "2024-01-01T00:00:00Z",
    "public_repos": 10,
    "total_private_repos": 5,
    "owned_private_repos": 5,
    "collaborators": 3,
    "two_factor_authentication": True,
    "plan": {
        "name": "enterprise",
        "space": 976562499,
        "private_repos": 999999
    }
}
```

### 3.8 Decision: Fluent API for Test Data Setup

**Choice:** Method chaining for test data creation

**Rationale:**
- Concise test setup code
- Self-documenting test preconditions
- Reduces boilerplate
- Matches `Type_Safe` patterns in the codebase

**Example:**
```python
surrogate = (GitHub__API__Surrogate()
             .setup()
             .add_repo("test-org", "test-repo")
             .add_environment("test-org", "test-repo", "production")
             .add_secret("test-org", "test-repo", "API_KEY", "secret123")
             .add_env_secret("test-org", "test-repo", "production", "DB_PASSWORD", "dbpass"))
```

---

## 4. Component Specifications

### 4.1 GitHub__API__Surrogate (Main Orchestrator)

```python
class GitHub__API__Surrogate(Type_Safe):
    """Main surrogate orchestrator - creates FastAPI app mocking api.github.com"""
    
    state      : GitHub__API__Surrogate__State
    pats       : GitHub__API__Surrogate__PATs
    keys       : GitHub__API__Surrogate__Keys
    routes     : GitHub__API__Surrogate__Routes
    _app       : FastAPI                        = None
    _client    : TestClient                     = None
    
    # Lifecycle
    def setup(self) -> 'GitHub__API__Surrogate':
        """Initialize all components and create FastAPI app"""
        
    def reset(self) -> 'GitHub__API__Surrogate':
        """Reset all state for test isolation"""
        
    def app(self) -> FastAPI:
        """Get the FastAPI application"""
        
    def test_client(self) -> TestClient:
        """Get TestClient for the app"""
    
    # Injection Methods
    def create_api(self, pat: str = None) -> GitHub__API:
        """Create a GitHub__API instance wired to this surrogate
        
        Args:
            pat: PAT to use. If None, uses admin PAT.
            
        Returns:
            GitHub__API with session pointing to surrogate
        """
        
    def inject(self, github_api: GitHub__API) -> GitHub__API:
        """Replace session on existing GitHub__API instance
        
        Args:
            github_api: Existing instance to modify
            
        Returns:
            Same instance with session replaced
        """
        
    def create_secrets(self, pat: str = None, repo_name: str = None) -> GitHub__Secrets:
        """Create a GitHub__Secrets instance wired to this surrogate"""
    
    # Fluent Test Data Helpers
    def add_repo(self, owner: str, repo: str) -> 'GitHub__API__Surrogate':
        """Add a repository to state"""
        
    def add_environment(self, owner: str, repo: str, environment: str) -> 'GitHub__API__Surrogate':
        """Add an environment to a repository"""
        
    def add_secret(self, owner: str, repo: str, name: str, value: str = None) -> 'GitHub__API__Surrogate':
        """Add a repository secret"""
        
    def add_env_secret(self, owner: str, repo: str, environment: str, name: str, value: str = None) -> 'GitHub__API__Surrogate':
        """Add an environment secret"""
        
    def add_org_secret(self, org: str, name: str, value: str = None, visibility: str = 'private') -> 'GitHub__API__Surrogate':
        """Add an organization secret"""
```

### 4.2 GitHub__API__Surrogate__State

```python
class GitHub__API__Surrogate__State(Type_Safe):
    """In-memory state for the GitHub API surrogate"""
    
    # User data indexed by PAT
    users          : Dict[str, Schema__Surrogate__User]
    
    # Repository data indexed by "owner/repo"
    repos          : Dict[str, Schema__Surrogate__Repo]
    
    # Secrets by scope
    secrets__repo  : Dict[str, Dict[str, Schema__Surrogate__Secret]]
    secrets__env   : Dict[str, Dict[str, Dict[str, Schema__Surrogate__Secret]]]
    secrets__org   : Dict[str, Dict[str, Schema__Surrogate__Secret]]
    
    # Public keys for encryption (generated per scope)
    public_keys    : Dict[str, Schema__Surrogate__Public_Key]
    
    # Rate limit tracking per PAT
    rate_limits    : Dict[str, Schema__Surrogate__Rate_Limit]
    
    # Environments per repo
    environments   : Dict[str, List[str]]  # "owner/repo" -> [env_names]
    
    def reset(self) -> 'GitHub__API__Surrogate__State':
        """Clear all state"""
        
    def get_user(self, pat: str) -> Optional[Schema__Surrogate__User]:
        """Get user associated with PAT"""
        
    def get_repo(self, owner: str, repo: str) -> Optional[Schema__Surrogate__Repo]:
        """Get repository by owner/repo"""
        
    def repo_exists(self, owner: str, repo: str) -> bool:
        """Check if repository exists"""
        
    def environment_exists(self, owner: str, repo: str, environment: str) -> bool:
        """Check if environment exists in repository"""
        
    def get_secret(self, owner: str, repo: str, name: str) -> Optional[Schema__Surrogate__Secret]:
        """Get repository secret"""
        
    def set_secret(self, owner: str, repo: str, name: str, encrypted_value: str, key_id: str) -> bool:
        """Create or update repository secret"""
        
    def delete_secret(self, owner: str, repo: str, name: str) -> bool:
        """Delete repository secret, returns True if existed"""
        
    # Similar methods for env and org secrets...
```

### 4.3 GitHub__API__Surrogate__PATs

```python
class Enum__GitHub__Scope(Enum):
    """GitHub OAuth scopes"""
    REPO                = 'repo'
    PUBLIC_REPO         = 'public_repo'
    ADMIN_ORG           = 'admin:org'
    WRITE_ORG           = 'write:org'
    READ_ORG            = 'read:org'
    WORKFLOW            = 'workflow'


class Schema__Surrogate__PAT(Type_Safe):
    """PAT definition with associated scopes"""
    token      : str
    user_login : str
    scopes     : List[Enum__GitHub__Scope]
    is_valid   : bool                      = True
    is_expired : bool                      = False
    is_rate_limited : bool                 = False


class GitHub__API__Surrogate__PATs(Type_Safe):
    """Pre-defined PATs for testing various permission scenarios"""
    
    # PAT Constants (40 chars like real GitHub PATs)
    PAT__ADMIN          : str = "ghp_surrogate_admin_"         + "A" * 21
    PAT__REPO_WRITE     : str = "ghp_surrogate_repo_write_"    + "B" * 17
    PAT__REPO_READ      : str = "ghp_surrogate_repo_read_"     + "C" * 18
    PAT__ORG_ADMIN      : str = "ghp_surrogate_org_admin_"     + "D" * 17
    PAT__ENV_ONLY       : str = "ghp_surrogate_env_only_"      + "E" * 18
    PAT__EXPIRED        : str = "ghp_surrogate_expired_"       + "F" * 19
    PAT__RATE_LIMITED   : str = "ghp_surrogate_rate_limited_"  + "G" * 14
    PAT__NO_SCOPES      : str = "ghp_surrogate_no_scopes_"     + "H" * 17
    PAT__INVALID        : str = "ghp_surrogate_invalid_"       + "I" * 19
    
    # PAT definitions with scopes
    _pats : Dict[str, Schema__Surrogate__PAT]
    
    def setup(self) -> 'GitHub__API__Surrogate__PATs':
        """Initialize PAT definitions"""
        
    # Convenience accessors
    def admin_pat(self) -> str:
        """Get admin PAT with full access"""
        return self.PAT__ADMIN
        
    def repo_write_pat(self) -> str:
        """Get PAT with repo write access"""
        return self.PAT__REPO_WRITE
        
    def repo_read_pat(self) -> str:
        """Get PAT with repo read-only access"""
        return self.PAT__REPO_READ
        
    def org_admin_pat(self) -> str:
        """Get PAT with org admin access"""
        return self.PAT__ORG_ADMIN
        
    def env_only_pat(self) -> str:
        """Get PAT with environment-only access"""
        return self.PAT__ENV_ONLY
        
    def expired_pat(self) -> str:
        """Get expired PAT (returns 401)"""
        return self.PAT__EXPIRED
        
    def rate_limited_pat(self) -> str:
        """Get rate-limited PAT (returns 429)"""
        return self.PAT__RATE_LIMITED
        
    def no_scopes_pat(self) -> str:
        """Get PAT with no scopes (returns 403 on operations)"""
        return self.PAT__NO_SCOPES
        
    def invalid_pat(self) -> str:
        """Get invalid PAT (returns 401)"""
        return self.PAT__INVALID
    
    # Validation
    def get_pat_info(self, pat: str) -> Optional[Schema__Surrogate__PAT]:
        """Get PAT definition if known"""
        
    def is_valid_pat(self, pat: str) -> bool:
        """Check if PAT is valid (known and not expired)"""
        
    def is_expired(self, pat: str) -> bool:
        """Check if PAT is expired"""
        
    def is_rate_limited(self, pat: str) -> bool:
        """Check if PAT is rate limited"""
        
    def has_scope(self, pat: str, scope: Enum__GitHub__Scope) -> bool:
        """Check if PAT has specific scope"""
        
    def can_read_repo_secrets(self, pat: str) -> bool:
        """Check if PAT can read repository secrets"""
        
    def can_write_repo_secrets(self, pat: str) -> bool:
        """Check if PAT can write repository secrets"""
        
    def can_admin_org(self, pat: str) -> bool:
        """Check if PAT can administer organization"""
```

### 4.4 GitHub__API__Surrogate__Session

```python
class GitHub__API__Surrogate__Session(Type_Safe):
    """requests.Session-compatible wrapper around TestClient
    
    This class provides the same interface as requests.Session
    so it can be injected into GitHub__API.session() slot.
    """
    
    test_client : TestClient
    _headers    : Dict[str, str]
    
    @property
    def headers(self) -> 'HeadersProxy':
        """Return headers proxy supporting .update()"""
        
    def get(self, url: str, **kwargs) -> Response:
        """Execute GET request via TestClient
        
        Converts full URLs to paths for TestClient.
        E.g., "https://api.github.com/user" -> "/user"
        """
        
    def put(self, url: str, json: dict = None, **kwargs) -> Response:
        """Execute PUT request via TestClient"""
        
    def delete(self, url: str, **kwargs) -> Response:
        """Execute DELETE request via TestClient"""
        
    def _convert_url_to_path(self, url: str) -> str:
        """Strip base URL to get path for TestClient"""
        
    def _prepare_headers(self, kwargs: dict) -> dict:
        """Merge instance headers with request headers"""


class HeadersProxy:
    """Proxy to support session.headers.update() pattern"""
    
    def __init__(self, session: GitHub__API__Surrogate__Session):
        self._session = session
        
    def update(self, headers: dict):
        """Update session headers"""
        self._session._headers.update(headers)
```

### 4.5 GitHub__API__Surrogate__Keys

```python
class Schema__Surrogate__Public_Key(Type_Safe):
    """Public key for secret encryption"""
    key_id     : str                      # Unique identifier
    key        : str                      # Base64-encoded public key
    created_at : str                      # ISO timestamp


class GitHub__API__Surrogate__Keys(Type_Safe):
    """Manages NaCl key pairs for secret encryption
    
    GitHub uses libsodium sealed boxes for secret encryption.
    Each scope (repo, environment, org) has its own key pair.
    """
    
    _key_pairs : Dict[str, Tuple[PrivateKey, PublicKey]]  # scope_id -> (private, public)
    
    def get_or_create_key_pair(self, scope_id: str) -> Schema__Surrogate__Public_Key:
        """Get or create key pair for scope
        
        Args:
            scope_id: Identifier like "repo:owner/repo" or "env:owner/repo/envname"
            
        Returns:
            Public key info matching GitHub's response format
        """
        
    def get_public_key(self, scope_id: str) -> Optional[Schema__Surrogate__Public_Key]:
        """Get public key if exists"""
        
    def decrypt_secret(self, scope_id: str, encrypted_value: str) -> str:
        """Decrypt a secret value (for validation/debugging)
        
        Args:
            scope_id: Scope identifier
            encrypted_value: Base64-encoded encrypted value
            
        Returns:
            Decrypted plaintext
        """
        
    def scope_id_for_repo(self, owner: str, repo: str) -> str:
        """Generate scope ID for repository secrets"""
        return f"repo:{owner}/{repo}"
        
    def scope_id_for_env(self, owner: str, repo: str, environment: str) -> str:
        """Generate scope ID for environment secrets"""
        return f"env:{owner}/{repo}/{environment}"
        
    def scope_id_for_org(self, org: str) -> str:
        """Generate scope ID for organization secrets"""
        return f"org:{org}"
```

### 4.6 GitHub__API__Surrogate__Routes

```python
class GitHub__API__Surrogate__Routes(Type_Safe):
    """FastAPI route definitions for GitHub API surrogate"""
    
    state : GitHub__API__Surrogate__State
    pats  : GitHub__API__Surrogate__PATs
    keys  : GitHub__API__Surrogate__Keys
    
    def create_app(self) -> FastAPI:
        """Create FastAPI app with all routes"""
        
    # Authentication/Authorization helpers
    def _extract_pat(self, authorization: str) -> str:
        """Extract PAT from Authorization header"""
        
    def _validate_pat(self, pat: str) -> Tuple[bool, int, str]:
        """Validate PAT and return (valid, status_code, error_message)"""
        
    def _check_scope(self, pat: str, required_scope: Enum__GitHub__Scope) -> Tuple[bool, int]:
        """Check if PAT has required scope"""
        
    # Route implementations
    def _route__user(self, authorization: str) -> Response:
        """GET /user - Get authenticated user"""
        
    def _route__rate_limit(self, authorization: str) -> Response:
        """GET /rate_limit - Get rate limit status"""
        
    def _route__repo_secrets_public_key(self, owner: str, repo: str, authorization: str) -> Response:
        """GET /repos/{owner}/{repo}/actions/secrets/public-key"""
        
    def _route__repo_secrets_list(self, owner: str, repo: str, authorization: str) -> Response:
        """GET /repos/{owner}/{repo}/actions/secrets"""
        
    def _route__repo_secret_get(self, owner: str, repo: str, secret_name: str, authorization: str) -> Response:
        """GET /repos/{owner}/{repo}/actions/secrets/{secret_name}"""
        
    def _route__repo_secret_put(self, owner: str, repo: str, secret_name: str, body: dict, authorization: str) -> Response:
        """PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}"""
        
    def _route__repo_secret_delete(self, owner: str, repo: str, secret_name: str, authorization: str) -> Response:
        """DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}"""
        
    # Similar routes for environments and organizations...
```

---

## 5. GitHub API Endpoints to Implement

### 5.1 Core Endpoints

| Method | Path | Description | Response |
|--------|------|-------------|----------|
| GET | `/user` | Get authenticated user | User object |
| GET | `/rate_limit` | Get rate limit status | Rate limit object |

### 5.2 Repository Secrets

| Method | Path | Description | Response |
|--------|------|-------------|----------|
| GET | `/repos/{owner}/{repo}/actions/secrets/public-key` | Get repo public key | `{key_id, key}` |
| GET | `/repos/{owner}/{repo}/actions/secrets` | List secrets | `{total_count, secrets: [...]}` |
| GET | `/repos/{owner}/{repo}/actions/secrets/{name}` | Get secret | `{name, created_at, updated_at}` |
| PUT | `/repos/{owner}/{repo}/actions/secrets/{name}` | Create/update secret | 201/204 |
| DELETE | `/repos/{owner}/{repo}/actions/secrets/{name}` | Delete secret | 204 |

### 5.3 Environment Secrets

| Method | Path | Description |
|--------|------|-------------|
| GET | `/repos/{owner}/{repo}/environments/{env}/secrets/public-key` | Get env public key |
| GET | `/repos/{owner}/{repo}/environments/{env}/secrets` | List env secrets |
| GET | `/repos/{owner}/{repo}/environments/{env}/secrets/{name}` | Get env secret |
| PUT | `/repos/{owner}/{repo}/environments/{env}/secrets/{name}` | Create/update env secret |
| DELETE | `/repos/{owner}/{repo}/environments/{env}/secrets/{name}` | Delete env secret |

### 5.4 Organization Secrets

| Method | Path | Description |
|--------|------|-------------|
| GET | `/orgs/{org}/actions/secrets/public-key` | Get org public key |
| GET | `/orgs/{org}/actions/secrets` | List org secrets |
| GET | `/orgs/{org}/actions/secrets/{name}` | Get org secret |
| PUT | `/orgs/{org}/actions/secrets/{name}` | Create/update org secret |
| DELETE | `/orgs/{org}/actions/secrets/{name}` | Delete org secret |

---

## 6. Error Response Patterns

The surrogate must return appropriate error responses matching GitHub's patterns:

### 6.1 Authentication Errors (401)

```python
# Invalid or expired PAT
{
    "message": "Bad credentials",
    "documentation_url": "https://docs.github.com/rest"
}
```

### 6.2 Authorization Errors (403)

```python
# Missing required scope
{
    "message": "Resource not accessible by integration",
    "documentation_url": "https://docs.github.com/rest"
}

# Rate limit exceeded
{
    "message": "API rate limit exceeded for user",
    "documentation_url": "https://docs.github.com/rest/rate-limit"
}
```

### 6.3 Not Found Errors (404)

```python
# Repository or secret not found
{
    "message": "Not Found",
    "documentation_url": "https://docs.github.com/rest"
}
```

---

## 7. Integration Patterns

### 7.1 Basic Usage in Tests

```python
def test_list_secrets():
    # Create surrogate with test data
    surrogate = (GitHub__API__Surrogate()
                 .setup()
                 .add_repo("test-org", "test-repo")
                 .add_secret("test-org", "test-repo", "API_KEY", "secret123"))
    
    # Create GitHub__Secrets instance wired to surrogate
    github_secrets = surrogate.create_secrets(
        pat       = surrogate.pats.admin_pat(),
        repo_name = "test-org/test-repo"
    )
    
    # Execute real code against surrogate
    secrets = github_secrets.list_secrets()
    
    # Assert
    assert len(secrets) == 1
    assert secrets[0]['name'] == 'API_KEY'
```

### 7.2 Testing Permission Errors

```python
def test_readonly_cannot_create_secret():
    surrogate = (GitHub__API__Surrogate()
                 .setup()
                 .add_repo("test-org", "test-repo"))
    
    # Use read-only PAT
    github_secrets = surrogate.create_secrets(
        pat       = surrogate.pats.repo_read_pat(),
        repo_name = "test-org/test-repo"
    )
    
    # Attempt to create secret - should fail with 403
    with pytest.raises(Exception) as exc_info:
        github_secrets.create_or_update_secret("NEW_SECRET", "value")
    
    assert "403" in str(exc_info.value)
```

### 7.3 Integration with GitHub Service

```python
def test_github_service_integration():
    # Create surrogate
    surrogate = (GitHub__API__Surrogate()
                 .setup()
                 .add_repo("test-org", "test-repo")
                 .add_secret("test-org", "test-repo", "EXISTING_SECRET", "value"))
    
    # Create GitHub Service in-memory
    with GitHub__Service__Fast_API() as service:
        service.setup()
        fast_api_app = service.app()
    
    # Inject surrogate into any GitHub__API instances the service creates
    # (This requires the service to use a factory pattern for GitHub__API)
    
    # Test via service client
    client = TestClient(fast_api_app)
    response = client.post('/github-secrets-repo/list', json={
        'encrypted_pat': encrypt_pat(surrogate.pats.admin_pat()),
        'request_data': {'owner': 'test-org', 'repo': 'test-repo'}
    })
    
    assert response.status_code == 200
    data = response.json()
    assert len(data['response_data']['secrets']) == 1
```

### 7.4 Deploy Service Integration Pattern

```python
# In Deploy Service tests

from mgraph_ai_service_github.surrogates.github import GitHub__API__Surrogate

@pytest.fixture
def github_surrogate():
    """Fixture providing GitHub API surrogate"""
    surrogate = GitHub__API__Surrogate().setup()
    yield surrogate
    surrogate.reset()

@pytest.fixture  
def github_service(github_surrogate):
    """Fixture providing GitHub Service wired to surrogate"""
    # Create in-memory GitHub Service
    service = GitHub__Service__Fast_API().setup()
    
    # Wire service's GitHub__API instances to surrogate
    # (Implementation depends on how service creates GitHub__API)
    
    return TestClient(service.app())

def test_deploy_with_secrets(github_surrogate, github_service):
    # Setup test data
    github_surrogate.add_repo("deploy-org", "deploy-repo")
    github_surrogate.add_secret("deploy-org", "deploy-repo", "AWS_KEY", "xxx")
    
    # Run deployment code that uses GitHub Service
    # ...
```

---

## 8. Type_Safe Compliance

All classes must follow `osbot-utils` Type_Safe patterns:

### 8.1 Class Definitions

```python
from osbot_utils.type_safe.Type_Safe import Type_Safe

class GitHub__API__Surrogate__State(Type_Safe):
    users    : Dict[str, Schema__Surrogate__User]    # Type annotations required
    repos    : Dict[str, Schema__Surrogate__Repo]
    # ... etc
```

### 8.2 Schema Classes

```python
from osbot_utils.type_safe.Type_Safe import Type_Safe

class Schema__Surrogate__User(Type_Safe):
    login                     : str
    id                        : int
    name                      : Optional[str] = None
    email                     : Optional[str] = None
    company                   : Optional[str] = None
    created_at                : Optional[str] = None
    public_repos              : int           = 0
    total_private_repos       : int           = 0
    owned_private_repos       : int           = 0
    collaborators             : int           = 0
    two_factor_authentication : bool          = False
    plan                      : Optional[Dict[str, Any]] = None
```

### 8.3 Formatting Conventions

Following the codebase style:

```python
class Example(Type_Safe):
    short_field : str                               # Right-aligned comments
    longer_name : Dict[str, Any]                    # Consistent spacing
    
    def method(self, param1 : str              ,    # Parameter alignment
                     param2 : int              ,
                     param3 : bool = False
               ) -> ReturnType:                     # Return type on new line
        
        result = dict(key1 = value1               , # Dict alignment
                      key2 = value2               )
        return result
```

---

## 9. Implementation Order

Recommended implementation sequence:

1. **Schemas** - Data structures first
   - `Schema__Surrogate__User`
   - `Schema__Surrogate__Repo`
   - `Schema__Surrogate__Secret`
   - `Schema__Surrogate__PAT`
   - `Schema__Surrogate__Rate_Limit`
   - `Schema__Surrogate__Public_Key`
   - `Enum__GitHub__Scope`

2. **PATs** - Authentication/authorization
   - `GitHub__API__Surrogate__PATs`

3. **State** - In-memory data management
   - `GitHub__API__Surrogate__State`

4. **Keys** - Encryption support
   - `GitHub__API__Surrogate__Keys`

5. **Session** - TestClient wrapper
   - `GitHub__API__Surrogate__Session`

6. **Routes** - FastAPI endpoints
   - `GitHub__API__Surrogate__Routes`

7. **Main** - Orchestrator
   - `GitHub__API__Surrogate`

8. **Tests** - Validate everything works

---

## 10. Success Criteria

The implementation is complete when:

1. ✅ All GitHub API endpoints used by `GitHub__API` and `GitHub__Secrets` are mocked
2. ✅ PAT validation enforces correct scope requirements
3. ✅ Error responses match GitHub's patterns (401, 403, 404, 429)
4. ✅ NaCl encryption/decryption works end-to-end
5. ✅ State can be reset between tests
6. ✅ Fluent API allows easy test data setup
7. ✅ Session injection works with existing `GitHub__API` code
8. ✅ All code follows Type_Safe patterns and codebase style
9. ✅ Published to PyPI as part of `mgraph-ai-service-github`
10. ✅ Deploy Service can import and use surrogate in tests

---

## Appendix A: GitHub API Response Examples

### A.1 GET /user

```json
{
    "login": "octocat",
    "id": 1,
    "name": "monalisa octocat",
    "email": "octocat@github.com",
    "company": "GitHub",
    "created_at": "2008-01-14T04:33:35Z",
    "public_repos": 2,
    "total_private_repos": 100,
    "owned_private_repos": 100,
    "collaborators": 8,
    "two_factor_authentication": true,
    "plan": {
        "name": "Medium",
        "space": 400,
        "private_repos": 20
    }
}
```

### A.2 GET /rate_limit

```json
{
    "rate": {
        "limit": 5000,
        "remaining": 4999,
        "reset": 1372700873,
        "used": 1
    }
}
```

### A.3 GET /repos/{owner}/{repo}/actions/secrets/public-key

```json
{
    "key_id": "568250167242549743",
    "key": "base64-encoded-public-key"
}
```

### A.4 GET /repos/{owner}/{repo}/actions/secrets

```json
{
    "total_count": 2,
    "secrets": [
        {
            "name": "GH_TOKEN",
            "created_at": "2019-08-10T14:59:22Z",
            "updated_at": "2020-01-10T14:59:22Z"
        },
        {
            "name": "GIST_ID",
            "created_at": "2020-01-10T10:59:22Z",
            "updated_at": "2020-01-11T11:59:22Z"
        }
    ]
}
```

---

## Appendix B: Related Code References

Key files in the existing codebase to understand:

- `mgraph_ai_service_github/service/github/GitHub__API.py` - API client to mock
- `mgraph_ai_service_github/service/github/GitHub__Secrets.py` - Secrets operations
- `mgraph_ai_service_github/service/auth/Service__Auth.py` - PAT handling
- `mgraph_ai_service_github/service/encryption/NaCl__Key_Management.py` - Key generation
- `mgraph_ai_service_github/fast_api/routes/Routes__GitHub__Secrets__Repo.py` - Route patterns