# MGraph-AI Service GitHub - LLM Briefing

## Document Information

| Field | Value |
|-------|-------|
| Service | MGraph-AI Service GitHub |
| Version | v0.7.1 |
| Deployment | https://github.dev.mgraph.ai/ |
| Purpose | REST API client integration guide |
| Focus | GitHub Secrets management with secure PAT handling |

---

## Executive Summary

The **MGraph-AI Service GitHub** is a FastAPI-based microservice that provides secure management of GitHub Secrets across three scopes: **Repository**, **Environment**, and **Organization**. 

The service implements a **client-side encryption architecture** where the caller's GitHub Personal Access Token (PAT) is encrypted locally before being sent in any request. This ensures the raw PAT **never traverses the network** to the server.

---

## Core Architecture: Client-Side PAT Encryption

### The Security Model

The service uses **NaCl SealedBox encryption** (Curve25519) to protect GitHub PATs:

```
┌─────────────────────────────────────────────────────────────────────┐
│                         CLIENT SIDE                                  │
├─────────────────────────────────────────────────────────────────────┤
│  1. Fetch server's public key from /encryption/public-key           │
│  2. Encrypt GitHub PAT locally using NaCl SealedBox                 │
│  3. Encrypt secret values locally using same public key             │
│  4. Send encrypted_pat + request_data in API calls                  │
└─────────────────────────────────────────────────────────────────────┘
                                │
                                ▼ (only encrypted data crosses network)
┌─────────────────────────────────────────────────────────────────────┐
│                         SERVER SIDE                                  │
├─────────────────────────────────────────────────────────────────────┤
│  1. Decrypt PAT using server's private key                          │
│  2. Decrypt secret values using same private key                    │
│  3. Use decrypted PAT to authenticate with GitHub API               │
│  4. Perform requested operation (list/get/create/update/delete)     │
│  5. Return response with rate limit info                            │
└─────────────────────────────────────────────────────────────────────┘
```

### Why This Matters

- **Raw PAT never sent to server** - Even if network traffic is intercepted, the PAT remains protected
- **Server cannot store PATs** - The server only sees encrypted blobs it can decrypt for immediate use
- **Secret values also protected** - When creating/updating secrets, the values are encrypted client-side

---

## Step-by-Step Integration Guide

### Step 1: Fetch the Server's Public Key

Before any GitHub Secrets operation, retrieve the server's NaCl public key:

```http
GET https://github.dev.mgraph.ai/encryption/public-key
```

**Response:**
```json
{
    "public_key": "a1b2c3d4e5f6...64_hex_characters...",
    "algorithm": "NaCl/Curve25519/SealedBox",
    "timestamp": 1734567890
}
```

**Cache this public key** - it remains stable for the lifetime of the deployment.

### Step 2: Encrypt Your GitHub PAT Locally

Using the public key, encrypt your GitHub PAT with NaCl SealedBox:

**Python example:**
```python
import base64
from nacl.public import PublicKey, SealedBox

def encrypt_with_public_key(value: str, public_key_hex: str) -> str:
    """Encrypt a value using the server's public key."""
    public_key_bytes = bytes.fromhex(public_key_hex)
    public_key       = PublicKey(public_key_bytes)
    sealed_box       = SealedBox(public_key)
    encrypted        = sealed_box.encrypt(value.encode('utf-8'))
    return base64.b64encode(encrypted).decode('utf-8')

# Usage
public_key_hex = "a1b2c3d4..."  # From /encryption/public-key
github_pat     = "ghp_xxxxxxxxxxxx"
encrypted_pat  = encrypt_with_public_key(github_pat, public_key_hex)
```

**JavaScript example:**
```javascript
import nacl from 'tweetnacl';
import { encodeBase64, decodeUTF8 } from 'tweetnacl-util';

function encryptWithPublicKey(value, publicKeyHex) {
    const publicKeyBytes = Buffer.from(publicKeyHex, 'hex');
    const messageBytes   = decodeUTF8(value);
    const encrypted      = nacl.box.seal(messageBytes, publicKeyBytes);
    return encodeBase64(encrypted);
}
```

### Step 3: Make GitHub Secrets API Calls

All GitHub Secrets endpoints follow the same request pattern:

```json
{
    "encrypted_pat": "<base64-encoded-encrypted-PAT>",
    "request_data": {
        // Operation-specific fields
    }
}
```

---

## GitHub Secrets API Reference

### Repository Secrets

Manage secrets at the repository level.

#### List Repository Secrets

```http
POST https://github.dev.mgraph.ai/github-secrets-repo/list
Content-Type: application/json

{
    "encrypted_pat": "<encrypted_pat>",
    "request_data": {
        "owner": "my-org",
        "repo": "my-repo"
    }
}
```

**Response:**
```json
{
    "response_context": {
        "success": true,
        "status_code": 200,
        "duration": 0.234,
        "timestamp": 1734567890,
        "messages": [],
        "errors": [],
        "error_type": "none",
        "rate_limit": {
            "limit": 5000,
            "remaining": 4998,
            "reset": 1734571490,
            "used": 2
        }
    },
    "response_data": {
        "secrets": [
            {
                "name": "AWS_ACCESS_KEY_ID",
                "created_at": "2024-01-15T10:30:00Z",
                "updated_at": "2024-03-20T14:45:00Z"
            },
            {
                "name": "AWS_SECRET_ACCESS_KEY",
                "created_at": "2024-01-15T10:30:00Z",
                "updated_at": "2024-03-20T14:45:00Z"
            }
        ]
    }
}
```

#### Get Repository Secret

```http
POST https://github.dev.mgraph.ai/github-secrets-repo/get
Content-Type: application/json

{
    "encrypted_pat": "<encrypted_pat>",
    "request_data": {
        "owner": "my-org",
        "repo": "my-repo",
        "secret_name": "AWS_ACCESS_KEY_ID"
    }
}
```

**Note:** GitHub API does not return secret values - only metadata (name, created_at, updated_at).

#### Create Repository Secret

When creating a secret, the **secret value must also be encrypted** using the same public key:

```python
encrypted_pat   = encrypt_with_public_key(github_pat, public_key_hex)
encrypted_value = encrypt_with_public_key("my-secret-value", public_key_hex)
```

```http
POST https://github.dev.mgraph.ai/github-secrets-repo/create
Content-Type: application/json

{
    "encrypted_pat": "<encrypted_pat>",
    "request_data": {
        "owner": "my-org",
        "repo": "my-repo",
        "secret_name": "NEW_SECRET",
        "encrypted_value": "<encrypted_secret_value>"
    }
}
```

**Response (success):**
```json
{
    "response_context": {
        "success": true,
        "status_code": 201,
        "messages": ["Secret 'NEW_SECRET' created"],
        ...
    },
    "response_data": {
        "created": true
    }
}
```

#### Update Repository Secret

```http
PUT https://github.dev.mgraph.ai/github-secrets-repo/update
Content-Type: application/json

{
    "encrypted_pat": "<encrypted_pat>",
    "request_data": {
        "owner": "my-org",
        "repo": "my-repo",
        "secret_name": "EXISTING_SECRET",
        "encrypted_value": "<encrypted_new_value>"
    }
}
```

#### Delete Repository Secret

```http
DELETE https://github.dev.mgraph.ai/github-secrets-repo/delete
Content-Type: application/json

{
    "encrypted_pat": "<encrypted_pat>",
    "request_data": {
        "owner": "my-org",
        "repo": "my-repo",
        "secret_name": "SECRET_TO_DELETE"
    }
}
```

---

### Environment Secrets

Manage secrets scoped to a specific GitHub Environment (e.g., `production`, `staging`).

#### List Environment Secrets

```http
POST https://github.dev.mgraph.ai/github-secrets-env/list
Content-Type: application/json

{
    "encrypted_pat": "<encrypted_pat>",
    "request_data": {
        "owner": "my-org",
        "repo": "my-repo",
        "environment": "production"
    }
}
```

#### Get Environment Secret

```http
POST https://github.dev.mgraph.ai/github-secrets-env/get
Content-Type: application/json

{
    "encrypted_pat": "<encrypted_pat>",
    "request_data": {
        "owner": "my-org",
        "repo": "my-repo",
        "environment": "production",
        "secret_name": "DATABASE_URL"
    }
}
```

#### Create Environment Secret

```http
POST https://github.dev.mgraph.ai/github-secrets-env/create
Content-Type: application/json

{
    "encrypted_pat": "<encrypted_pat>",
    "request_data": {
        "owner": "my-org",
        "repo": "my-repo",
        "environment": "production",
        "secret_name": "DATABASE_URL",
        "encrypted_value": "<encrypted_secret_value>"
    }
}
```

#### Update Environment Secret

```http
PUT https://github.dev.mgraph.ai/github-secrets-env/update
Content-Type: application/json

{
    "encrypted_pat": "<encrypted_pat>",
    "request_data": {
        "owner": "my-org",
        "repo": "my-repo",
        "environment": "production",
        "secret_name": "DATABASE_URL",
        "encrypted_value": "<encrypted_new_value>"
    }
}
```

#### Delete Environment Secret

```http
DELETE https://github.dev.mgraph.ai/github-secrets-env/delete
Content-Type: application/json

{
    "encrypted_pat": "<encrypted_pat>",
    "request_data": {
        "owner": "my-org",
        "repo": "my-repo",
        "environment": "production",
        "secret_name": "DATABASE_URL"
    }
}
```

---

### Organization Secrets

Manage secrets at the organization level. Requires organization admin permissions.

#### List Organization Secrets

```http
POST https://github.dev.mgraph.ai/github-secrets-org/list
Content-Type: application/json

{
    "encrypted_pat": "<encrypted_pat>",
    "request_data": {
        "org": "my-org"
    }
}
```

**Response includes visibility information:**
```json
{
    "response_data": {
        "secrets": [
            {
                "name": "ORG_WIDE_SECRET",
                "visibility": "all",
                "created_at": "2024-01-15T10:30:00Z",
                "updated_at": "2024-03-20T14:45:00Z",
                "selected_repositories_url": null
            },
            {
                "name": "PRIVATE_REPOS_ONLY",
                "visibility": "private",
                ...
            }
        ]
    }
}
```

#### Get Organization Secret

```http
POST https://github.dev.mgraph.ai/github-secrets-org/get
Content-Type: application/json

{
    "encrypted_pat": "<encrypted_pat>",
    "request_data": {
        "org": "my-org",
        "secret_name": "ORG_WIDE_SECRET"
    }
}
```

#### Create Organization Secret

Organization secrets support **visibility** settings:
- `"all"` - Available to all repositories
- `"private"` - Available only to private repositories
- `"selected"` - Available only to specified repositories (provide `repo_ids`)

```http
POST https://github.dev.mgraph.ai/github-secrets-org/create
Content-Type: application/json

{
    "encrypted_pat": "<encrypted_pat>",
    "request_data": {
        "org": "my-org",
        "secret_name": "NEW_ORG_SECRET",
        "encrypted_value": "<encrypted_secret_value>",
        "visibility": "private"
    }
}
```

**With selected repositories:**
```json
{
    "encrypted_pat": "<encrypted_pat>",
    "request_data": {
        "org": "my-org",
        "secret_name": "SELECTED_SECRET",
        "encrypted_value": "<encrypted_secret_value>",
        "visibility": "selected",
        "repo_ids": [123456789, 987654321]
    }
}
```

#### Update Organization Secret

```http
PUT https://github.dev.mgraph.ai/github-secrets-org/update
Content-Type: application/json

{
    "encrypted_pat": "<encrypted_pat>",
    "request_data": {
        "org": "my-org",
        "secret_name": "EXISTING_ORG_SECRET",
        "encrypted_value": "<encrypted_new_value>",
        "visibility": "all"
    }
}
```

#### Delete Organization Secret

```http
DELETE https://github.dev.mgraph.ai/github-secrets-org/delete
Content-Type: application/json

{
    "encrypted_pat": "<encrypted_pat>",
    "request_data": {
        "org": "my-org",
        "secret_name": "SECRET_TO_DELETE"
    }
}
```

---

## Response Structure

All GitHub Secrets endpoints return a consistent response structure:

### Response Context

| Field | Type | Description |
|-------|------|-------------|
| `success` | boolean | Whether the operation succeeded |
| `status_code` | integer | HTTP status code (200, 201, 401, 403, 404, 429, 500) |
| `duration` | float | Execution time in seconds |
| `timestamp` | integer | Unix timestamp of response |
| `messages` | array | Informational messages |
| `errors` | array | Error details if failed |
| `error_type` | string | Error classification (see below) |
| `rate_limit` | object | GitHub API rate limit information |

### Error Types

| Error Type | Description |
|------------|-------------|
| `none` | No error |
| `decryption_failed` | Failed to decrypt PAT or secret value |
| `invalid_pat` | GitHub rejected the PAT (bad credentials) |
| `not_found` | Secret or resource not found |
| `forbidden` | PAT lacks required permissions |
| `rate_limited` | GitHub API rate limit exceeded |
| `github_api_error` | Other GitHub API error |

### Rate Limit Information

Every successful response includes GitHub's rate limit status:

```json
{
    "rate_limit": {
        "limit": 5000,
        "remaining": 4995,
        "reset": 1734571490,
        "used": 5
    }
}
```

---

## Complete Python Client Example

```python
import base64
import requests
from nacl.public import PublicKey, SealedBox
from functools import lru_cache

class GitHubSecretsClient:
    """Client for MGraph-AI GitHub Secrets Service."""
    
    def __init__(self, base_url: str = "https://github.dev.mgraph.ai"):
        self.base_url   = base_url
        self.session    = requests.Session()
        self._pat       = None
        
    def set_github_pat(self, pat: str):
        """Set the GitHub PAT to use for operations."""
        self._pat = pat
    
    @lru_cache(maxsize=1)
    def _get_public_key(self) -> str:
        """Fetch and cache the server's public key."""
        response = self.session.get(f"{self.base_url}/encryption/public-key")
        response.raise_for_status()
        return response.json()["public_key"]
    
    def _encrypt(self, value: str) -> str:
        """Encrypt a value using the server's public key."""
        public_key_hex   = self._get_public_key()
        public_key_bytes = bytes.fromhex(public_key_hex)
        public_key       = PublicKey(public_key_bytes)
        sealed_box       = SealedBox(public_key)
        encrypted        = sealed_box.encrypt(value.encode('utf-8'))
        return base64.b64encode(encrypted).decode('utf-8')
    
    @property
    def encrypted_pat(self) -> str:
        """Get the encrypted PAT."""
        if not self._pat:
            raise ValueError("GitHub PAT not set. Call set_github_pat() first.")
        return self._encrypt(self._pat)
    
    # ═══════════════════════════════════════════════════════════════
    # Repository Secrets
    # ═══════════════════════════════════════════════════════════════
    
    def list_repo_secrets(self, owner: str, repo: str) -> dict:
        """List all secrets in a repository."""
        return self._post("/github-secrets-repo/list", {
            "owner": owner,
            "repo": repo
        })
    
    def get_repo_secret(self, owner: str, repo: str, secret_name: str) -> dict:
        """Get metadata for a repository secret."""
        return self._post("/github-secrets-repo/get", {
            "owner": owner,
            "repo": repo,
            "secret_name": secret_name
        })
    
    def create_repo_secret(self, owner: str, repo: str, 
                           secret_name: str, secret_value: str) -> dict:
        """Create a new repository secret."""
        return self._post("/github-secrets-repo/create", {
            "owner": owner,
            "repo": repo,
            "secret_name": secret_name,
            "encrypted_value": self._encrypt(secret_value)
        })
    
    def update_repo_secret(self, owner: str, repo: str,
                           secret_name: str, secret_value: str) -> dict:
        """Update an existing repository secret."""
        return self._put("/github-secrets-repo/update", {
            "owner": owner,
            "repo": repo,
            "secret_name": secret_name,
            "encrypted_value": self._encrypt(secret_value)
        })
    
    def delete_repo_secret(self, owner: str, repo: str, secret_name: str) -> dict:
        """Delete a repository secret."""
        return self._delete("/github-secrets-repo/delete", {
            "owner": owner,
            "repo": repo,
            "secret_name": secret_name
        })
    
    # ═══════════════════════════════════════════════════════════════
    # Environment Secrets
    # ═══════════════════════════════════════════════════════════════
    
    def list_env_secrets(self, owner: str, repo: str, environment: str) -> dict:
        """List all secrets in an environment."""
        return self._post("/github-secrets-env/list", {
            "owner": owner,
            "repo": repo,
            "environment": environment
        })
    
    def create_env_secret(self, owner: str, repo: str, environment: str,
                          secret_name: str, secret_value: str) -> dict:
        """Create a new environment secret."""
        return self._post("/github-secrets-env/create", {
            "owner": owner,
            "repo": repo,
            "environment": environment,
            "secret_name": secret_name,
            "encrypted_value": self._encrypt(secret_value)
        })
    
    # ═══════════════════════════════════════════════════════════════
    # Organization Secrets
    # ═══════════════════════════════════════════════════════════════
    
    def list_org_secrets(self, org: str) -> dict:
        """List all secrets in an organization."""
        return self._post("/github-secrets-org/list", {"org": org})
    
    def create_org_secret(self, org: str, secret_name: str, secret_value: str,
                          visibility: str = "private", 
                          repo_ids: list = None) -> dict:
        """Create a new organization secret."""
        request_data = {
            "org": org,
            "secret_name": secret_name,
            "encrypted_value": self._encrypt(secret_value),
            "visibility": visibility
        }
        if repo_ids:
            request_data["repo_ids"] = repo_ids
        return self._post("/github-secrets-org/create", request_data)
    
    # ═══════════════════════════════════════════════════════════════
    # HTTP Helpers
    # ═══════════════════════════════════════════════════════════════
    
    def _post(self, endpoint: str, request_data: dict) -> dict:
        payload = {
            "encrypted_pat": self.encrypted_pat,
            "request_data": request_data
        }
        response = self.session.post(f"{self.base_url}{endpoint}", json=payload)
        return response.json()
    
    def _put(self, endpoint: str, request_data: dict) -> dict:
        payload = {
            "encrypted_pat": self.encrypted_pat,
            "request_data": request_data
        }
        response = self.session.put(f"{self.base_url}{endpoint}", json=payload)
        return response.json()
    
    def _delete(self, endpoint: str, request_data: dict) -> dict:
        payload = {
            "encrypted_pat": self.encrypted_pat,
            "request_data": request_data
        }
        response = self.session.delete(f"{self.base_url}{endpoint}", json=payload)
        return response.json()


# ═══════════════════════════════════════════════════════════════════════
# Usage Example
# ═══════════════════════════════════════════════════════════════════════

if __name__ == "__main__":
    client = GitHubSecretsClient()
    client.set_github_pat("ghp_your_personal_access_token")
    
    # List repository secrets
    result = client.list_repo_secrets("my-org", "my-repo")
    
    if result["response_context"]["success"]:
        for secret in result["response_data"]["secrets"]:
            print(f"  - {secret['name']}")
    else:
        print(f"Error: {result['response_context']['errors']}")
    
    # Create a new secret
    result = client.create_repo_secret(
        owner        = "my-org",
        repo         = "my-repo",
        secret_name  = "API_KEY",
        secret_value = "super-secret-value"
    )
    print(f"Created: {result['response_context']['success']}")
```

---

## GitHub PAT Requirements

The GitHub Personal Access Token used with this service must have appropriate scopes:

| Operation | Required Scope |
|-----------|---------------|
| Repository Secrets | `repo` (Full control of private repositories) |
| Environment Secrets | `repo` |
| Organization Secrets | `admin:org` |

For fine-grained personal access tokens, grant:
- **Repository permissions:** Secrets (Read and write)
- **Organization permissions:** Secrets (Read and write) - for org secrets

---

## Secret Name Constraints

GitHub enforces these rules for secret names:
- Only alphanumeric characters `[a-zA-Z0-9]` and underscores `[_]`
- Cannot start with a number
- Cannot start with `GITHUB_` prefix (reserved)
- Maximum 255 characters

---

## Service Health & Info Endpoints

### Health Check

```http
GET https://github.dev.mgraph.ai/info/health
```

### Service Status

```http
GET https://github.dev.mgraph.ai/info/status
```

### Version Information

```http
GET https://github.dev.mgraph.ai/info/version
```

```http
GET https://github.dev.mgraph.ai/info/versions
```

---

## Additional Routes (Debugging & Experimentation)

The following endpoints are available primarily for debugging, testing, and experimentation. They are **not recommended for production use** as they involve sending sensitive data to the server or expose internal functionality:

| Endpoint | Method | Purpose |
|----------|--------|---------|
| `/auth/token-create` | POST | Create encrypted token from raw PAT (sent via header) |
| `/auth/token-validate` | POST | Validate an encrypted PAT token |
| `/auth/test` | GET | Test encrypted PAT against GitHub API |
| `/auth/test-api-key` | GET | Test service is running and accessible |
| `/encryption/encrypt` | POST | Server-side encryption of values |
| `/encryption/decrypt` | POST | Server-side decryption of values |
| `/encryption/validate` | POST | Validate encrypted data can be decrypted |
| `/encryption/generate-keys` | GET | Generate new NaCl key pair |
| `/auth/set-cookie-form` | GET | Cookie management form |
| `/auth/set-auth-cookie` | POST | Set authentication cookie |

For production integrations, always use the **client-side encryption approach** documented in this guide.

---

## Summary

1. **Fetch public key** once from `/encryption/public-key`
2. **Encrypt PAT locally** using NaCl SealedBox
3. **Encrypt secret values locally** when creating/updating secrets
4. **Send encrypted data** in all API requests
5. **Check response_context.success** and handle errors appropriately
6. **Monitor rate_limit** to avoid GitHub API throttling

The service provides a secure way to manage GitHub Secrets without ever exposing your PAT in transit.
